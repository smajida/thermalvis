#!/usr/bin/env python
# chmod a+x streamer.cfg
PACKAGE = "thermalvis"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

#gen.add("source", str_t, 0, "Type of input source", "dev")
#gen.add("file", str_t, 0, "Input file address", "file")
#gen.add("dev", str_t, 0, "Input device address", "/dev/video0")
#gen.add("folder", str_t, 0, "Input folder address", "./")
#gen.add("topic", str_t, 0, "Input topic for reprocessing", "/thermalvis/miricle_streamer/image_raw")

detector_datatype = gen.enum([ 
	gen.const("RAW", int_t, 0, "Raw detector mode"),
	gen.const("LUM", int_t, 1, "Luminance-corrected mode"),
	gen.const("INS", int_t, 2, "Instrument mode (recommended)"),
	gen.const("RAD", int_t, 3, "Radiance mode (radiometric cameras only)"),
	gen.const("TMP", int_t, 4, "Temperature mode (radiometric cameras only)") ],
	"An enum to set the detector output mode")
	
gen.add("detectorMode", int_t, 0, "Output of thermal-infrared detector", 2, 0, 4, edit_method=detector_datatype)

usb_datatype = gen.enum([ 
	gen.const("16", int_t, 1, "Camera will output in 16-bit format"),
	gen.const("8", int_t, 2, "Camera will output in 8-bit format"), ],
	"An enum to set the usb output mode")
	
gen.add("usbMode", int_t, 0, "USB output format (16/8-bit) of camera", 1, 1, 2, edit_method=usb_datatype)

input_datatype = gen.enum([ 
	gen.const("8bit", int_t, 0, "8-bit single channel"),
	gen.const("raw", int_t, 1, "Raw 16-bit format"),
	gen.const("mm", int_t, 2, "8-bit dual channel (multimodal)"),
	gen.const("16uc1", int_t, 3, "16-bit from kinect depth") ],
	"An enum to set the bits/pixel")
	
gen.add("inputDatatype", int_t, 0, "Pixel format of input", 1, 0, 3, edit_method=input_datatype)

gen.add("maxReadAttempts", int_t, 0, "Maximum number of times to attempt to read frame before accepting failure (0 = infinite)", 0, 0, 100)

#gen.add("fixDudPixels", bool_t, 0, "Interpolate values of invalid pixels", True)

#gen.add("forceInputGray", bool_t, 0, "Forces color input to be converted to gray", False)

gen.add("framerate", double_t, 0, "Desired Framerate", -1.0, -1.0, 100.0)

norm_enum = gen.enum([ 
	gen.const("standard", int_t, 0, "Standard dynamic range"),
	gen.const("equalize", int_t, 1, "Equalization"),
	gen.const("clahe", int_t, 2, "CLAHE"),
	gen.const("clahe_adaptive", int_t, 3, "Adaptive Contrast Enhancement"),
	gen.const("centralized", int_t, 4, "Centers intensities around median"),
	gen.const("expanded", int_t, 5, "Centers intensities around mid-range") ],
	"An enum to set the normalization scheme")
	
gen.add("normMode", int_t, 0, "Histogram Normalization Mode", 0, 0, 5, edit_method=norm_enum)

gen.add("normFactor", double_t, 0, "Normalization factor", 0.0, 0.0, 1.0)
#gen.add("stepChangeTempScale", bool_t, 0, "When autoscaling temperature, sticks with discrete ranges", False)

filter_enum = gen.enum([ 
	gen.const("none", int_t, 0, "No filtering"),
	gen.const("gaussian", int_t, 1, "Gaussian Filter"),
	gen.const("bilateral", int_t, 2, "Bilateral Filter"),
	gen.const("adaptive_bilateral", int_t, 3, "Adaptive Bilateral Filter")],
	"An enum to set the normalization scheme")
	
#gen.add("filterMode", int_t, 0, "Image Filtering Mode", 0, 0, 3, edit_method=filter_enum)
#gen.add("filterParam", double_t, 0, "Filter param", 2.0, 0.0, 20.0)

gen.add("output16bit", bool_t, 0, "Activate 16-bit (raw) output", False)
gen.add("output8bit", bool_t, 0, "Activeate 8-bit (mono) output", False)
gen.add("outputColor", bool_t, 0, "Activate color output", True)

mapping_enum = gen.enum([ 
	gen.const("GRAYSCALE", int_t, 0, "Grayscale coloring"),
	gen.const("CIECOMP", int_t, 1, "CIECOMP coloring"),
	gen.const("BLACKBODY", int_t, 2, "Blackbody coloring"),
	gen.const("RAINBOW", int_t, 3, "Rainbow coloring"),
	gen.const("IRON", int_t, 4, "Iron coloring"),
	gen.const("BLUERED", int_t, 5, "Blue-red coloring"),
	gen.const("JET", int_t, 6, "Jet coloring"),
	gen.const("CIELUV", int_t, 7, "CIELUV coloring"),
	gen.const("ICEIRON", int_t, 8, "Ice and iron coloring"),
	gen.const("ICEFIRE", int_t, 9, "Ice and fire coloring"),
	gen.const("REPEATED", int_t, 10, "Ice and fire coloring"),
	gen.const("HIGHLIGHTED", int_t, 11, "Highlights dominant pixels as red") ],
	"An enum to set the color mapping scheme")
                  
gen.add("map", int_t, 0, "A color mapping parameter which is edited via an enum", 7, 0, 11, edit_method=mapping_enum)
                  
#gen.add("extremes", bool_t, 0, "Allow b/w color mapping", True)

#gen.add("writeImages", bool_t, 0, "Activate write output", False)

#format_enum = gen.enum([ 
#	gen.const("jpg", int_t, 0, "JPEG"),
#	gen.const("pgm", int_t, 1, "PGM"),
#	gen.const("bmp", int_t, 2, "BMP"),
#	gen.const("ppm", int_t, 3, "PPM"),
#	gen.const("png", int_t, 4, "PNG") ],
#	"An enum to set the output image format")
	
#gen.add("outputFormat", int_t, 0, "Output image format", 0, 0, 4, edit_method=format_enum)

type_enum = gen.enum([ 
	gen.const("CV_8UC1", int_t, 0, "8-bit single channel"),
	gen.const("CV_8UC3", int_t, 1, "8-bit triple channel"),
	gen.const("CV_16UC1", int_t, 2, "16-bit single channel") ],
	"An enum to set the output image type")
	
#gen.add("outputType", int_t, 0, "Output image type", 2, 0, 4, edit_method=type_enum)

#gen.add("writeQuality", double_t, 0, "Write quality", 1.0, 0.0, 1.0)

#gen.add("keepOriginalNames", bool_t, 0, "Keep original names", True)

#gen.add("loopMode", bool_t, 0, "Re-loop once finished", False)

gen.add("undistortImages", bool_t, 0, "Activate image undistortion", False)

#gen.add("rectifyImages", bool_t, 0, "Activate image rectification", False)

#gen.add("alpha", double_t, 0, "Alpha level for undistortion", 0.0, -1.0, 1.0)

#gen.add("autoAlpha", bool_t, 0, "Automatically find best alpha level", True)

#gen.add("temporalSmoothing", bool_t, 0, "Regulate change in median intensity (8-bit only)", False)
#gen.add("maxShift", int_t, 0, "Maximum amount of intensity shift (8-bit only)", 2, 0, 20)
#gen.add("temporalMemory", int_t, 0, "Maximum amount of past frames to consider", 5, 0, 100)

#gen.add("removeDuplicates", bool_t, 0, "Remove consecutive duplicate frames", False)
#gen.add("markDuplicates", bool_t, 0, "Mark consecutive duplicate frames", False)

#gen.add("dumpDuplicates", bool_t, 0, "Output duplicates to a log-file", False)

#gen.add("dumpTimestamps", bool_t, 0, "Output timestamps to console", False)

gen.add("fusionFactor", double_t, 0, "Scaling range for modality fusion", 0.6, 0.0, 1.0)

#gen.add("syncDiff", double_t, 0, "Maximum difference in seconds for soft sync", 0.005, 0.000, 1.000)

#gen.add("readThermistor", bool_t, 0, "Read thermistor values", True)
#gen.add("smoothThermistor", bool_t, 0, "Smooth thermistor values", False)
#gen.add("thermistorWindow", double_t, 0, "Time (s) to use to smooth thermistor readings", 5.0, 0.0, 30.0)
#gen.add("alternatePeriod", int_t, 0, "No. of polls between alternating (calibration mode only)", 10, 0, 1000)
gen.add("serialPollingRate", double_t, 0, "Rate (per sec) for serial polling", 25.0, 0.0, 100.0)
gen.add("maxNucInterval", int_t, 0, "Maximum NUC interval (in sec)", 45, 0, 300)
gen.add("maxNucThreshold", double_t, 0, "Maximum NUC threshold (in deg C)", 0.2, 0.0, 100.0)
#gen.add("maxThermistorDiff", double_t, 0, "Maximum temp difference between consecutive thermistor readings", 0.5, 0.0, 10.0)

gen.add("verboseMode", bool_t, 0, "Display additional debug info", False)
#gen.add("displayThermistor", bool_t, 0, "Display the thermistor temperature", False)

#HGH
#gen.add("drawReticle", bool_t, 0, "Overlay reticle", False)

# RADIOMETRY
#gen.add("radiometricCorrection", bool_t, 0, "Enable image correction using radiometric information", True)
#gen.add("alreadyCorrected", bool_t, 0, "Subscribed 16-bit data already in (N-1000)/10 brightness temp format (e.g. Optris)", False)
#gen.add("radiometricRaw", bool_t, 0, "Convert 16-bit raw output to (N-1000)/10 radiometrically correct representation", False)
#gen.add("radiometricInterpolation", bool_t, 0, "Interpolate for more accurate temperature estimates", True)
#gen.add("radiometricBias", int_t, 0, "Bias to shift graylevel so that the image data fits the radiometric model", 0, -10000, +10000);
gen.add("autoTemperature", bool_t, 0, "Automatically select temperature limits based on image range", False)
gen.add("minTemperature", double_t, 0, "Minimum temperature", 20.0, -50.0, 200.0)
gen.add("maxTemperature", double_t, 0, "Maximum temperature", 40.0, -50.0, 200.0)

exit(gen.generate(PACKAGE, "streamer", "streamer"))
